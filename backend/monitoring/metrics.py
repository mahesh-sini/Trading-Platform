"""
Prometheus metrics for the trading platform
"""

import time
import logging
from typing import Dict, Any, List
from functools import wraps
from prometheus_client import (
    Counter, Histogram, Gauge, Summary, Info,
    generate_latest, CONTENT_TYPE_LATEST,
    start_http_server
)
from threading import Lock

logger = logging.getLogger(__name__)

class TradingMetrics:
    """Comprehensive metrics collection for trading platform"""
    
    def __init__(self):
        # Trading metrics
        self.trades_total = Counter(
            'trading_trades_total',
            'Total number of trades executed',
            ['symbol', 'side', 'strategy', 'status']
        )
        
        self.trade_value = Histogram(
            'trading_trade_value_usd',
            'Value of trades in USD',
            ['symbol', 'side', 'strategy'],
            buckets=[100, 500, 1000, 5000, 10000, 50000, 100000, float('inf')]
        )
        
        self.trade_latency = Histogram(
            'trading_trade_latency_seconds',
            'Time taken to execute trades',
            ['symbol', 'side'],
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.0, 5.0, float('inf')]
        )
        
        self.portfolio_value = Gauge(
            'trading_portfolio_value_usd',
            'Current portfolio value in USD',
            ['user_id']
        )
        
        self.position_size = Gauge(
            'trading_position_size',
            'Current position size',
            ['symbol', 'user_id']
        )
        
        self.unrealized_pnl = Gauge(
            'trading_unrealized_pnl_usd',
            'Unrealized profit and loss in USD',
            ['symbol', 'user_id']
        )
        
        self.realized_pnl = Counter(
            'trading_realized_pnl_usd_total',
            'Total realized profit and loss in USD',
            ['symbol', 'user_id', 'result']  # result: profit/loss
        )
        
        # Strategy metrics
        self.strategy_signals = Counter(
            'trading_strategy_signals_total',
            'Total signals generated by strategies',
            ['strategy_id', 'strategy_type', 'signal_type', 'symbol']
        )
        
        self.strategy_performance = Gauge(
            'trading_strategy_performance_ratio',
            'Strategy performance ratios',
            ['strategy_id', 'metric']  # metric: sharpe_ratio, win_rate, etc.
        )
        
        self.strategy_execution_time = Histogram(
            'trading_strategy_execution_seconds',
            'Time taken for strategy execution',
            ['strategy_id', 'strategy_type'],
            buckets=[0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, float('inf')]
        )
        
        # Market data metrics
        self.market_data_updates = Counter(
            'trading_market_data_updates_total',
            'Total market data updates received',
            ['symbol', 'data_type', 'provider']  # data_type: price, volume, orderbook; provider: nse, yahoo, alpha_vantage, polygon
        )
        
        self.market_data_latency = Histogram(
            'trading_market_data_latency_seconds',
            'Market data latency',
            ['symbol', 'data_type', 'provider'],
            buckets=[0.001, 0.01, 0.1, 0.5, 1.0, 5.0, float('inf')]
        )
        
        self.market_data_freshness = Gauge(
            'trading_market_data_age_seconds',
            'Age of market data in seconds',
            ['symbol', 'data_type', 'provider']
        )
        
        # Live market data provider metrics
        self.provider_api_calls = Counter(
            'trading_provider_api_calls_total',
            'Total API calls to market data providers',
            ['provider', 'endpoint', 'status']
        )
        
        self.provider_rate_limits = Gauge(
            'trading_provider_rate_limit_remaining',
            'Remaining API calls for provider rate limits',
            ['provider']
        )
        
        self.provider_errors = Counter(
            'trading_provider_errors_total',
            'Total errors from market data providers',
            ['provider', 'error_type']
        )
        
        self.live_subscriptions = Gauge(
            'trading_live_subscriptions_active',
            'Number of active real-time market data subscriptions',
            ['provider', 'symbol']
        )
        
        # API metrics
        self.api_requests = Counter(
            'trading_api_requests_total',
            'Total API requests',
            ['method', 'endpoint', 'status_code']
        )
        
        self.api_latency = Histogram(
            'trading_api_request_duration_seconds',
            'API request duration',
            ['method', 'endpoint'],
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.0, 5.0, float('inf')]
        )
        
        # Database metrics
        self.db_operations = Counter(
            'trading_db_operations_total',
            'Total database operations',
            ['operation', 'table', 'status']
        )
        
        self.db_latency = Histogram(
            'trading_db_operation_duration_seconds',
            'Database operation duration',
            ['operation', 'table'],
            buckets=[0.001, 0.01, 0.1, 0.5, 1.0, 5.0, float('inf')]
        )
        
        self.db_connections = Gauge(
            'trading_db_connections_active',
            'Active database connections',
            ['database']
        )
        
        # ML metrics
        self.ml_predictions = Counter(
            'trading_ml_predictions_total',
            'Total ML predictions made',
            ['model_name', 'symbol', 'prediction_type']
        )
        
        self.ml_model_accuracy = Gauge(
            'trading_ml_model_accuracy_ratio',
            'ML model accuracy',
            ['model_name', 'symbol']
        )
        
        self.ml_inference_time = Histogram(
            'trading_ml_inference_duration_seconds',
            'ML model inference time',
            ['model_name'],
            buckets=[0.001, 0.01, 0.1, 0.5, 1.0, 5.0, float('inf')]
        )
        
        # Risk metrics
        self.risk_violations = Counter(
            'trading_risk_violations_total',
            'Total risk limit violations',
            ['violation_type', 'symbol', 'user_id']
        )
        
        self.risk_exposure = Gauge(
            'trading_risk_exposure_ratio',
            'Current risk exposure',
            ['symbol', 'user_id', 'risk_type']
        )
        
        # System metrics
        self.system_errors = Counter(
            'trading_system_errors_total',
            'Total system errors',
            ['service', 'error_type']
        )
        
        self.active_sessions = Gauge(
            'trading_active_sessions',
            'Number of active user sessions'
        )
        
        self.websocket_connections = Gauge(
            'trading_websocket_connections_active',
            'Active WebSocket connections',
            ['connection_type']
        )
        
        # Performance summary metrics
        self.response_time_summary = Summary(
            'trading_response_time_seconds',
            'Response time summary',
            ['service', 'operation']
        )
        
        # Application info
        self.app_info = Info(
            'trading_app_info',
            'Trading application information'
        )
        
        # Thread safety
        self._lock = Lock()
        
    def record_trade(self, trade_data: Dict[str, Any]):
        """Record a trade execution"""
        try:
            symbol = trade_data.get('symbol', 'unknown')
            side = trade_data.get('side', 'unknown')
            strategy = trade_data.get('strategy', 'unknown')
            status = trade_data.get('status', 'unknown')
            value = trade_data.get('value', 0)
            latency = trade_data.get('latency', 0)
            
            self.trades_total.labels(
                symbol=symbol,
                side=side,
                strategy=strategy,
                status=status
            ).inc()
            
            if value > 0:
                self.trade_value.labels(
                    symbol=symbol,
                    side=side,
                    strategy=strategy
                ).observe(value)
            
            if latency > 0:
                self.trade_latency.labels(
                    symbol=symbol,
                    side=side
                ).observe(latency)
                
        except Exception as e:
            logger.error(f"Error recording trade metrics: {str(e)}")
    
    def update_portfolio(self, user_id: str, portfolio_data: Dict[str, Any]):
        """Update portfolio metrics"""
        try:
            total_value = portfolio_data.get('total_value', 0)
            positions = portfolio_data.get('positions', {})
            
            self.portfolio_value.labels(user_id=user_id).set(total_value)
            
            for symbol, position in positions.items():
                self.position_size.labels(
                    symbol=symbol,
                    user_id=user_id
                ).set(position.get('quantity', 0))
                
                self.unrealized_pnl.labels(
                    symbol=symbol,
                    user_id=user_id
                ).set(position.get('unrealized_pnl', 0))
                
        except Exception as e:
            logger.error(f"Error updating portfolio metrics: {str(e)}")
    
    def record_strategy_signal(self, strategy_data: Dict[str, Any]):
        """Record strategy signal generation"""
        try:
            strategy_id = strategy_data.get('strategy_id', 'unknown')
            strategy_type = strategy_data.get('strategy_type', 'unknown')
            signal_type = strategy_data.get('signal_type', 'unknown')
            symbol = strategy_data.get('symbol', 'unknown')
            execution_time = strategy_data.get('execution_time', 0)
            
            self.strategy_signals.labels(
                strategy_id=strategy_id,
                strategy_type=strategy_type,
                signal_type=signal_type,
                symbol=symbol
            ).inc()
            
            if execution_time > 0:
                self.strategy_execution_time.labels(
                    strategy_id=strategy_id,
                    strategy_type=strategy_type
                ).observe(execution_time)
                
        except Exception as e:
            logger.error(f"Error recording strategy signal metrics: {str(e)}")
    
    def update_strategy_performance(self, strategy_id: str, metrics: Dict[str, float]):
        """Update strategy performance metrics"""
        try:
            for metric_name, value in metrics.items():
                self.strategy_performance.labels(
                    strategy_id=strategy_id,
                    metric=metric_name
                ).set(value)
                
        except Exception as e:
            logger.error(f"Error updating strategy performance metrics: {str(e)}")
    
    def record_market_data_update(self, data_info: Dict[str, Any]):
        """Record market data updates"""
        try:
            symbol = data_info.get('symbol', 'unknown')
            data_type = data_info.get('data_type', 'unknown')
            provider = data_info.get('provider', 'unknown')
            latency = data_info.get('latency', 0)
            age = data_info.get('age', 0)
            
            self.market_data_updates.labels(
                symbol=symbol,
                data_type=data_type,
                provider=provider
            ).inc()
            
            if latency > 0:
                self.market_data_latency.labels(
                    symbol=symbol,
                    data_type=data_type,
                    provider=provider
                ).observe(latency)
            
            if age >= 0:
                self.market_data_freshness.labels(
                    symbol=symbol,
                    data_type=data_type,
                    provider=provider
                ).set(age)
                
        except Exception as e:
            logger.error(f"Error recording market data metrics: {str(e)}")
    
    def record_provider_api_call(self, call_info: Dict[str, Any]):
        """Record API call to market data provider"""
        try:
            provider = call_info.get('provider', 'unknown')
            endpoint = call_info.get('endpoint', 'unknown')
            status = call_info.get('status', 'unknown')
            
            self.provider_api_calls.labels(
                provider=provider,
                endpoint=endpoint,
                status=status
            ).inc()
            
        except Exception as e:
            logger.error(f"Error recording provider API call metrics: {str(e)}")
    
    def update_provider_rate_limit(self, provider: str, remaining: int):
        """Update provider rate limit remaining"""
        try:
            self.provider_rate_limits.labels(provider=provider).set(remaining)
        except Exception as e:
            logger.error(f"Error updating provider rate limit metrics: {str(e)}")
    
    def record_provider_error(self, error_info: Dict[str, Any]):
        """Record error from market data provider"""
        try:
            provider = error_info.get('provider', 'unknown')
            error_type = error_info.get('error_type', 'unknown')
            
            self.provider_errors.labels(
                provider=provider,
                error_type=error_type
            ).inc()
            
        except Exception as e:
            logger.error(f"Error recording provider error metrics: {str(e)}")
    
    def update_live_subscription(self, provider: str, symbol: str, active: bool):
        """Update live subscription count"""
        try:
            if active:
                self.live_subscriptions.labels(provider=provider, symbol=symbol).set(1)
            else:
                self.live_subscriptions.labels(provider=provider, symbol=symbol).set(0)
        except Exception as e:
            logger.error(f"Error updating live subscription metrics: {str(e)}")
    
    def record_api_request(self, request_info: Dict[str, Any]):
        """Record API request metrics"""
        try:
            method = request_info.get('method', 'unknown')
            endpoint = request_info.get('endpoint', 'unknown')
            status_code = str(request_info.get('status_code', 'unknown'))
            duration = request_info.get('duration', 0)
            
            self.api_requests.labels(
                method=method,
                endpoint=endpoint,
                status_code=status_code
            ).inc()
            
            if duration > 0:
                self.api_latency.labels(
                    method=method,
                    endpoint=endpoint
                ).observe(duration)
                
        except Exception as e:
            logger.error(f"Error recording API request metrics: {str(e)}")
    
    def record_db_operation(self, operation_info: Dict[str, Any]):
        """Record database operation metrics"""
        try:
            operation = operation_info.get('operation', 'unknown')
            table = operation_info.get('table', 'unknown')
            status = operation_info.get('status', 'unknown')
            duration = operation_info.get('duration', 0)
            
            self.db_operations.labels(
                operation=operation,
                table=table,
                status=status
            ).inc()
            
            if duration > 0:
                self.db_latency.labels(
                    operation=operation,
                    table=table
                ).observe(duration)
                
        except Exception as e:
            logger.error(f"Error recording database operation metrics: {str(e)}")
    
    def record_ml_prediction(self, prediction_info: Dict[str, Any]):
        """Record ML prediction metrics"""
        try:
            model_name = prediction_info.get('model_name', 'unknown')
            symbol = prediction_info.get('symbol', 'unknown')
            prediction_type = prediction_info.get('prediction_type', 'unknown')
            inference_time = prediction_info.get('inference_time', 0)
            accuracy = prediction_info.get('accuracy')
            
            self.ml_predictions.labels(
                model_name=model_name,
                symbol=symbol,
                prediction_type=prediction_type
            ).inc()
            
            if inference_time > 0:
                self.ml_inference_time.labels(
                    model_name=model_name
                ).observe(inference_time)
            
            if accuracy is not None:
                self.ml_model_accuracy.labels(
                    model_name=model_name,
                    symbol=symbol
                ).set(accuracy)
                
        except Exception as e:
            logger.error(f"Error recording ML prediction metrics: {str(e)}")
    
    def record_risk_violation(self, violation_info: Dict[str, Any]):
        """Record risk violation"""
        try:
            violation_type = violation_info.get('violation_type', 'unknown')
            symbol = violation_info.get('symbol', 'unknown')
            user_id = violation_info.get('user_id', 'unknown')
            
            self.risk_violations.labels(
                violation_type=violation_type,
                symbol=symbol,
                user_id=user_id
            ).inc()
            
        except Exception as e:
            logger.error(f"Error recording risk violation metrics: {str(e)}")
    
    def set_app_info(self, app_info: Dict[str, str]):
        """Set application information"""
        try:
            self.app_info.info(app_info)
        except Exception as e:
            logger.error(f"Error setting app info: {str(e)}")
    
    def get_metrics(self) -> str:
        """Get Prometheus metrics in text format"""
        return generate_latest()
    
    def get_content_type(self) -> str:
        """Get Prometheus content type"""
        return CONTENT_TYPE_LATEST

# Global metrics instance
trading_metrics = TradingMetrics()

def timed_metric(metric_name: str, labels: Dict[str, str] = None):
    """Decorator to time function execution and record metrics"""
    def decorator(func):
        @wraps(func)
        async def async_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                duration = time.time() - start_time
                
                # Record the timing
                trading_metrics.response_time_summary.labels(
                    service=labels.get('service', 'unknown') if labels else 'unknown',
                    operation=metric_name
                ).observe(duration)
                
                return result
            except Exception as e:
                duration = time.time() - start_time
                
                # Record error timing
                trading_metrics.response_time_summary.labels(
                    service=labels.get('service', 'unknown') if labels else 'unknown',
                    operation=f"{metric_name}_error"
                ).observe(duration)
                
                raise
        
        @wraps(func)
        def sync_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = func(*args, **kwargs)
                duration = time.time() - start_time
                
                # Record the timing
                trading_metrics.response_time_summary.labels(
                    service=labels.get('service', 'unknown') if labels else 'unknown',
                    operation=metric_name
                ).observe(duration)
                
                return result
            except Exception as e:
                duration = time.time() - start_time
                
                # Record error timing
                trading_metrics.response_time_summary.labels(
                    service=labels.get('service', 'unknown') if labels else 'unknown',
                    operation=f"{metric_name}_error"
                ).observe(duration)
                
                raise
        
        # Return appropriate wrapper based on function type
        if asyncio.iscoroutinefunction(func):
            return async_wrapper
        else:
            return sync_wrapper
    
    return decorator

def start_metrics_server(port: int = 8000):
    """Start Prometheus metrics HTTP server"""
    try:
        start_http_server(port)
        logger.info(f"Metrics server started on port {port}")
    except Exception as e:
        logger.error(f"Failed to start metrics server: {str(e)}")